一切都是事件驱动的

时间提示事件
发现新文章事件
获取到新文章事件

每个处理事件具体内容的都是一个线程
需要注意的是: EventBus.post 会等到运行完成才会返回,所以需要长时间处理的内容为单独的线程

关于线程的处理
: 在处理 时间提示事件 事件的时候,当满足了调度,发布事件的时候均使用异步发布
这样会
	让每个发布事件在单个线程
	也就是说每个事件处理都是在单个线程
		那么还有必要让事件处理的时候使用额外的线程么?
			还是有必要的,因为
				对于事件处理过程,他对它的上下文是没有概念的,所以不应该意识到是在单独的线程里
				同时,自己管理线程会更方便,可以处理一些异常以及超时等操作
				使用线程,使得 EventBus 发布事件的那个线程早点结束,因为这里没有任何的异常处理,只是为了便于异步发布

? 是否需要每个事件都有一个完成事件,即事件状态
	? 可否将事件状态记录到一个事件,以完成多个事件状态 (e.isComplete() 即表示完成状态)
		如果这样做
			在事件较多的时候,很多事件处理会接收到很多不需要处理的事件
			而且在每个处理事件中,都需要判断一下事件状态,这样很是麻烦
	? 可否使用统一的完成时间, ( CompleteEvent.getEvent() )
		如果这样做
			那些需要处理完成事件的才需要关心这个事件
			同时也可以引入 start 事件
				例如:
				handleEvent(e)
					处理(e)
					bus.complete(e)
					
				handleStartEvent(e)
					log(开始处理事件 e.getEvent())
					bus.trigger(e)
					
				handleCompleteEvent(e)
					log(事件 e 已经处理完成)
				
? 是否需要将该 EventBus 作为全局可访问的
	如果这样做
		上述的实现会相对比较简单
		提取出一个全局的 EventBus 也是可以理解的

主要需要调度的事件
: 间隔发现新文章(基于 URL)
	主页
	rank/home
: 当一个文章的评论更新完成的时候
	添加下次更新的调度事件
: 间隔的检查数据库中的文章,查看是否有需要更新的
	这里的条件待定~

显示统计的 SQL
-- 总数查询
select "总数" as `统计`, 
	(select count(*) from cbhistory_article) as `文章`, 
	(select count(*) from cbhistory_comment) as `评论`,
	(select count(a.c) from 
		(select count(sid) as c from cbhistory_comment group by sid) as a) as `有评论的文章`,
	(select now()) as `查询日期`;

-- 最新文章
select n.title as `最新文章标题`, n.date as `最新文章时间` 
	from (select * from cbhistory_article order by date desc limit 0,1) as n;
-- 最旧文章
select o.title as `最旧文章标题`, o.date as `最旧文章时间` 
	from (select * from cbhistory_article order by date asc limit 0,1) as o;

-- 最早有评论的文章
select sid,date,title from cbhistory_article where sid = (select sid from cbhistory_comment order by date asc limit 0,1);
-- 最新有评论的文章
select sid,date,title from cbhistory_article where sid = (select sid from cbhistory_comment order by date desc limit 0,1);

-- 获取数据库的大小
SELECT table_schema                                        "DB Name", 
   Round(Sum(data_length + index_length) / 1024 / 1024, 1) "DB Size in MB" 
FROM   information_schema.tables 
GROUP  BY table_schema; 

H2 中这样导出 SQL

script to 'filenam'

统计记录
=========

2014-05-04 17:29
-----
+------+------+------+--------------+
| 统计 | 文章 | 评论 | 有评论的文章 |
+------+------+------+--------------+
| 总数 |  278 | 3479 |          192 |
+------+------+------+--------------+

2014-05-06 19:46
----------
+------+------+------+--------------+
| 统计 | 文章 | 评论 | 有评论的文章 |
+------+------+------+--------------+
| 总数 |  549 | 8157 |          441 |
+------+------+------+--------------+

+------+------+-------+--------------+---------------------+
| 统计 | 文章 | 评论  | 有评论的文章 | 查询日期            |
+------+------+-------+--------------+---------------------+
| 总数 |  834 | 12346 |          679 | 2014-05-08 18:58:34 |
+------+------+-------+--------------+---------------------+

+------+------+-------+--------------+---------------------+
| 统计 | 文章 | 评论  | 有评论的文章 | 查询日期            |
+------+------+-------+--------------+---------------------+
| 总数 | 2212 | 35102 |         1922 | 2014-05-19 23:46:38 |
+------+------+-------+--------------+---------------------+

查询 几天前的sql
----
http://stackoverflow.com/questions/14497662

mysql日期函数
-------------
http://dev.mysql.com/doc/refman/5.1/en/date-and-time-functions.html

选择过去 6 - 7 天的
----
select count(*) from cbhistory_article 
where date between  
	DATE_SUB(DATE(NOW()), INTERVAL 7 DAY)
	AND DATE_SUB(DATE(NOW()), INTERVAL 6 DAY);

非常接近过期了
--------------
select count(*) from cbhistory_article 
	WHERE date between 
	DATE_SUB(NOW(), INTERVAL 24*7 + 1 HOUR)
	AND DATE_SUB(DATE(NOW()), INTERVAL 24*6 + 12 HOUR);

	
并发控制
--------
map: id -> date/event
	
在开始处理一个文章的时候,检测在该map里有没有处理的id,检测时间是否超时

? 是否只在一个事件处理中检测
? 是否只在文章处理的时候检测
? 如果使用event作为value,则使用弱引用,如果该引用无效了,则说明该处理完成了
	否则就手动控制开始和结束
? 什么时候算开始,什么时候算结束~
? 如何判断一连串的事件处理的是否是同一个文章
	* 以 article 作为 key 可以判断
		* 但是 article 会改变,在持久化后有可能article会不是当前的article
		
-> 结论: 暂时放弃这个的实现

更好的更新策略
-------------

文章的更新不只是更新文章的评论,还包括了文章的一些基本信息.
	例如: 浏览量,顶的次数
为了确保这些信息能尽量的保持一直,所以需要缩短文章更新的间隔.
但是这里需要注意的是,这样的文章是不需要获取文章的页面,只需要
评论的信息.获取文章页面,只有在第一次发现新文章的时候,才需要做这样的操作.

为了更新文章的这些信息,所以可以忽视掉文章的过期时间.
? 这样会导致大量的更新么?
	* 应该是不会的,因为只会在 主页,排行榜,主页推荐上发现文章,如果一个文章
	过期太久是不会出现在这些地方的,而出现在这些地方的文章一般也都算是相对比较重要的.
	* 如果更新的文章是已经过期的,那返回的请求量也会比较小,此时可以判断是否含有评论数据,
	如果没有评论数据,则不使用该数据该更新评论信息

主要的处理过程
---------------
过程
	开始->时间提示事件
	
	处理 时间提示事件
		检索注册的事件中是否有满足触发的事件
	
	处理 尝试发现文章
		获取网页 HTML
		解析出文章列表
		解析出文章的所有 ID
	    发送 发现了文章(每个文章都要发送一个该事件,第一次执行的时候会触发很多次)
	
	处理 发现了文章 事件,判断服务器中是否有该文章信息
		有
			判断是否过期(超过了三天)
				已过期
					记录 debug 日志/日志事件
						发现的文章已过期
				未过期
					发送 更新文章评论事件
		没有
			发送 发现新文章事件
				
				
	处理 发现新文章事件 事件  (获取新文章,解析新文章)
		获取新文章的HTML
			获取HTML -> 有可能发生异常,有可能超时
			发送 解析新文章事件
			OR
			解析新文章
			解析出 ArticleDetail 对象
			发送 更新文章评论事件
			
	处理 更新文章评论事件 (获取文章评论,解析文章评论)
		生成 OP
		发送请求
		解析内容
		解析出 Comment 对象
		发送 更新文章评论完成事件
		
允许跨域的设置
response.setHeader("Access-Control-Allow-Origin", "*");
response.setHeader("Access-Control-Allow-Methods", "POST, GET");
response.setHeader("Access-Control-Max-Age", "3600");
response.setHeader("Access-Control-Allow-Headers", "x-requested-with");
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
