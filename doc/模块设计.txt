模块结构
	core
		目前为 guice + guava
	db-ormlite
		使用 ormlite 作为持久层的实现
	db-spring-data
		使用 spring-data-jpa 作为持久层实现
		如果引入 spring,则必须要使用 guice 和 spring 的集成包
	server-madvoc
		使用 madvoc 实现的服务端
	server-madvoc-jetty
		作为本地使用时,使用jetty作为服务器来运行
		? 这个模块或许不应该依赖于 madvoc,单独的一个 server
	server
		是否需要实现一个这样公共的server呢~?
		这个似乎也很有用,因为后面可能会使用 springMvc 来实现服务器
		但是由于使用的不同的服务实现,这个server应该怎么抽取呢~?
		一个 rest 路径对应一个返回值,主要定义返回值~?
		在这个模块里没有 rest 这些概念,定义返回值的类型,模式
	server-spring: spring-data-jpa
		使用 spring 来作为服务器实现,后端使用 spring-data-jpa
		
		
如果实现插件式的模块?
	me.wener.cbhistory.modules
	使用该命名空间作为模块装入的扫描包 ?
		OrmliteModule
		SpringDataModule
		MadvocModule
		...
	这些模块必须 extends PluginModule(自己实现,继承自 AbstractModule)
	
	如何通知这些模块?
		1. 事件式的模块加载事件处理(PluginModule.EventBus)
			用于告知模块
				模块开始加载
				模块加载完成
				甚至取消模块的加载 ?
				
	模块何时被实例化?
		在App start 前
		在App 初始化后
		PluginAwareModule 中
		
	模块何时被加载 ?
		需要 PluginModule 实现一个 plugin 方法,这样插件就能自己控制加载时机
			比如说,可以在 PostConstruts 时加载
		
进程
	实现 PluginAwareModule, 使程序能够意识到插件
	[放弃] 将 ormlite 从 core 中抽取出来
		命名空间: me.wener.cbhistory.persistence.ormlite
		更改 Article 和 Comment
			需要将这两个改为接口
			使用 Entities.of(IEntity) 来实例化
				内部使用 App.getInjector().getInstance
		将 ArticleService 和 CommentService 的实现提取出来
		将 PersistsModule 拿出来
		这里需要注意 也需要将 RawDataService 实现拿出来
			但是core默认提供一个基于 缓存 实现的 RawDataService
	实现一个简单的服务器 wsdl,因为 必须返回 xml,所以需要在外层套一个 <cbhistory /> 就好了
		在客户端解析的时候,需要注意这一点
	抽取出 ormlite 后,再实现 server-madvoc
	如果在实现madvoc的过程中发现可以抽取的东西,再抽为 server
		
	
	
如果使用缓存实现 RawDataService
	何时缓存
		findOne
	何时清除缓存
		当 article 更新的时候,需要清楚对应 id 的缓存
		如何知道 article 更新?
			1. 更新文章完成事件,判断该 id
			
是否对 article 也进行缓存 ?
	
抽取 Article 和 Comment 时出现严重的问题
	1. 这些实体类的属性上定义了如何序列化 json 的注解
		gson 不支持setter和getter
		所以必须得保留 Article 和 Comment,否则的话只能更换使用的 JSON 库
	2. 因为 Service 的接口参数都是用的 Article 和 Comment
		所以在写子类的时候略微比较蛋疼
		在实现 Service 的时候都是 Article 和 Comment 的子类
		返回结果集的时候处理起来非常伤脑筋
	3. ormlite 的 databaseField 必须定义在 field 上,这里也很蛋疼了
	
新的思路:
	不再抽出 ormlite, core默认绑定一套持久层的实现,
	如果需要集成 spring data 的时候,说明是其他的东西需要使用,core依然使用ormlite
	